
## ООП

1. Наследование — абстрактный тип данных может наследовать данные и функциональность существующего типа, что способствует повторному использованию кода.
2. Инкапсуляция — сокрытие реализации и предоставление только необходимого интерфейса.
3. Полиморфизм — разные объекты могут реагировать на один и тот же запрос, проявляя разное поведение в зависимости от своего типа.
4. Абстракция — выделение значимых характеристик объекта при игнорировании несущественных деталей.

---
## GRASP

GRASP выделяет следующие 9 принципов-шаблонов:
1. Information Expert (Информационный эксперт) — ответственность за выполнение операций возлагается на тот класс, который обладает всей необходимой информацией для их выполнения.
2. Creator (Создатель) — Объект получает ответственность за создание другого объекта, если он его использует, агрегирует или знает, как его инициализировать.
3. Controller (Контроллер) — посредник между пользовательским интерфейсом и бизнес-логикой, управляющий обработкой входящих запросов от UI.
4. Low Coupling (Слабая связанность) — объекты должны быть слабо связаны между собой, чтобы изменения в одном минимально затрагивали другие.
5. High Cohesion (Высокая сцепленность) — объект должен быть сфокусирован на выполнении одной задачи или группы тесно связанных задач, что упрощает поддержку и понимание. 

Пример нарушения:

```java
@AllArgsConstructor
public class Data {
  private int temperature;
  private int time;

  private int calculateTimeDifference(int time) {
    return this.time - time;
  }

  private int calculateTemperatureDifference(int temperature) {
    return this.temperature - temperature;
  }
}
```

Пример соблюдения:

```java
@AllArgsConstructor
public class Data {
  private TemperatureData temperatureData;
  private TimeData timeData;

  public Data(int time, int temperature) {
    this.temperatureData = new TemperatureData(temperature);
    this.timeData = new TimeData(time);
  }

  // тут логика по работе как со временем, так и с температурой

}

@AllArgsConstructor
public class TimeData {
  private int time;

  private int calculateTimeDifference(int time) {
    return this.time - time;
  }
}

@AllArgsConstructor
public class TemperatureData {
  private int temperature;

  private int calculateTemperatureDifference(int temperature) {
    return this.temperature - temperature;
}
```

6. Pure Fabrication (Чистая выдумка) — искусственно созданный класс, не отражающий сущности предметной области, но обеспечивающий высокую сцепленность и низкую связанность.
7. Indirection (Посредник) — введение посредника между компонентами снижает связанность и упрощает замену или расширение поведения.
8. Protected Variations (Защищённые изменения) — стабильность системы достигается через абстракции, скрывающие потенциально изменяемые части от остального кода.
9. Polymorphism (Полиморфизм) — пdsfозволяет обрабатывать объекты разных типов через общий интерфейс, обеспечивая гибкость в реализации альтернативных поведений.

---
## Контракт `equals()` и `hashCode()`

Если два объекта равны согласно `equals()`, то их `hashCode()` обязательно должен быть одинаковым. Это необходимо для корректной работы в хеш-коллекциях.

Метод `equals()` должен соблюдать следующие свойства:
- рефлексивность: `a.equals(a)` всегда возвращает `true`;
- симметричность: `a.equals(b)` ⇔ `b.equals(a)`;
- транзитивность: если `a.equals(b)` и `b.equals(c)`, то `a.equals(c)`;
- консистентность: многократные вызовы с теми же аргументами дают одинаковый результат;
- обработка `null`: `a.equals(null)` всегда должно возвращать `false`.

### Реализация `equals()`

1. С использованием `getClass()` (точное совпадение классов):
	- используется строгая проверка на класс;
	- `Person` не будет равен `Student`, даже если `Student` наследует `Person`.

Пример:

```java
@Override
public boolean equals(Object o) {
  if (this == o) return true;
  if (o == null || getClass() != o.getClass()) return false;
  Person person = (Person) o;
  return age == person.age && Objects.equals(name, person.name);
}
```

2. С использованием `instanceof` (допускает сравнение с подклассами):
	- допускается сравнение объектов родительского и дочернего классов;
	- подходит для иерархий, где логика сравнения остаётся совместимой.

Пример:

```java
@Override
public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof Person)) return false;
  Person person = (Person) o;
  return age == person.age && Objects.equals(name, person.name);
}
```

### Реализация `hashCode()`

1. Рекомендуется использовать стратегию из Effective Java:

```java
@Override
public int hashCode() {
  int result = 17;
  result = 31 * result + name.hashCode();
  result = 31 * result + (int)(phone ^ (phone >>> 32));
  result = 31 * result + age;
  return result;
}
```

2. Также можно использовать упрощённый способ:

```java
@Override
public int hashCode() {
  return Objects.hash(name, phone, age);
}
```

Общие правила для вычисления хеш-кода:
- `boolean`: `f ? 1 : 0`;
- `int`: `(int) f`;
- `long`: `(int)(f ^ (f >>> 32))`;
- `float`: `Float.floatToIntBits(f)`;
- `double`: сначала преобразовать в `long`, затем по правилу для `long`;
- `Object`: `f.hashCode()`, или `0`, если `f == null`;
- массивы: использовать `Arrays.hashCode(...)` или `Arrays.deepHashCode(...)` для вложенных структур.

Практические рекомендации:
- всегда переопределяйте `hashCode()` при переопределении `equals()`;
- используйте одни и те же поля для обоих методов;
- обеспечьте устойчивое распределение хешей для минимизации коллизий.

Контракт:
1. если два объекта равны по `equals()`, их `hashCode()` должен быть одинаковым;
2. обратное не обязательно: разные объекты могут иметь одинаковый `hashCode()` (коллизия);
3. если `equals()` переопределён без `hashCode()`, хеш-коллекции могут работать некорректно.

---
## Статическое и динамическое связывание в Java

Связывание (binding) — это процесс сопоставления вызова метода с его конкретной реализацией в коде.

### Типы связывания

1. Статическое связывание (early binding) — осуществляется во время компиляции и опирается на тип ссылочной переменной. Используется для `static`, `final`, `private` методов, а также при перегрузке методов (method overloading). Компилятор заранее знает, какой именно метод будет вызван.
2. Динамическое связывание (late binding) — происходит во время выполнения и зависит от реального типа объекта в памяти. Применяется для переопределённых (`overridden`) экземплярных методов. Решение о том, какую реализацию метода вызвать, принимается JVM в момент вызова.

Виртуальный метод — это экземплярный метод, который может быть переопределён в подклассе. Вызов такого метода выполняется через динамическое связывание, позволяя реализовать полиморфизм.

---
## Коллекции

Иерархия коллекций:

![[Resources/Collections/collections.png]]

`Map` — ассоциативный массив:

![[Resources/Collections/map.png]]

Коллекции со сортировкой: `TreeMap`, `TreeSet`, `PriorityQueue`
Коллекции со сортировкой по вставке: `LinkedHashMap`, `LinkedHashSet`

### ArrayList

`ArrayList` — расширенная версия массива.

Недостатки обычных массивов:
- фиксированный размер — нужно заранее знать, сколько элементов будет;
- нет встроенных методов для добавления и удаления — все операции выполняются вручную.

Преимущества `ArrayList`:
- автоматически расширяется при добавлении новых элементов;
- работает с объектами, как и массив, но предоставляет более гибкий и удобный интерфейс;
- можно легко добавлять, заменять, удалять элементы, узнавать их позиции и количество;
- в отличие от массива, при выводе используется переопределённый `toString()`, что делает вывод удобным.

Преобразование между массивом и `ArrayList`:
- из массива в список: `new ArrayList<>(Arrays.asList(array))`;
- из списка в массив: `list.toArray(new Cat[0])`.

Дополнительные особенности:
- можно указать начальную вместимость при создании, но список всё равно будет расширяться при необходимости;
- в отличие от свойства `length` у массива, метод `size()` у ArrayList возвращает текущее количество элементов, а не ёмкость.
#### Внутреннее устройство

`ArrayList` внутри использует обычный массив, но:
- при заполнении создаёт новый массив размером `(старый * 1.5) + 1`.
- копирует все элементы в него;
- старый удаляется сборщиком мусора.

### LinkedList

LinkedList в Java — двусвязный список. Он удобен для задач, связанных с частыми вставками и удалениями в середине списка.

Строение LinkedList:
- это двусвязный список: каждый элемент содержит ссылки на предыдущий и следующий;
- элементы объединены в цепочку, по которой можно двигаться в обоих направлениях;
- в отличие от `ArrayList`, внутри `LinkedList` нет массива — он работает исключительно со ссылками.

Отличие от ArrayList:
- в `ArrayList` операции вставки и удаления требуют сдвига элементов, особенно в середине. В `LinkedList` — лишь перенастройка ссылок;
- `ArrayList` эффективен для быстрого доступа по индексу и добавления в конец. `LinkedList` — при частом добавлении и удалении в начале или середине списка.

#### Практическое сравнение

Вставка 100 элементов в середину:

```text
LinkedList: ~1800 мс
ArrayList: ~180 мс
```

Хотя `LinkedList` должен быть эффективнее, `ArrayList` оказался быстрее из-за следующих факторов:
- доступ по индексу у `ArrayList` — мгновенный (через массив);
- в `LinkedList` нужно последовательно пройти к нужному элементу по ссылкам.
Но при вставке в начало:

```text
LinkedList: ~100 мс
ArrayList: ~43000 мс
```

Здесь `LinkedList` оказался в сотни раз быстрее — ему не нужно сдвигать элементы.

### HashMap

Хеш-таблица – структура данных, реализующая интерфейс ассоциативного массива ("ключ–значение"). Элементы хранятся в массиве, где позиция определяется хеш-функцией. Хеш-функция преобразует ключ в целое число (хеш-код), которое затем используется для вычисления индекса в массиве. Важно: хеш-функция должна быть консистентной (одинаковые ключи → одинаковый хеш). 

Внутреннее устройство `HashMap` — массив (`Node<K,V>[] table`) односвязных списков или красно-черных деревьев (для борьбы с коллизиями).

Коллизии возникают, когда разные ключи попадают в один бакет. Решаются методами: 
- метод цепочек (в одном бакете хранится связный список или дерево);
- открытая адресация (поиск следующей свободной ячейки, не используется в HashMap). 

Поля класса HashMap: 
- `transient Node<K,V>[] table` – массив бакетов;
- `int size` – количество элементов;
- `float loadFactor` – коэффициент загрузки (по умолчанию 0.75); 
- `int threshold` – порог увеличения размера (`capacity * loadFactor`). 

Константы: 
- `DEFAULT_INITIAL_CAPACITY = 16` (начальный размер);
- `TREEIFY_THRESHOLD = 8` – переход списка в дерево;
- `UNTREEIFY_THRESHOLD = 6` – обратный переход;
- `MIN_TREEIFY_CAPACITY = 64` – минимальный размер для дерева. 

Алгоритм работы при добавлении элементов: 
1. вычисление хеша: `hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)` (смешивание старших и младших бит);
2. определение бакета: `index = (n - 1) & hash`, где `n` – размер массива;
3. проверка бакета: 
	- если бакет пуст – создается новый `Node`;
	- если есть коллизия: 
		- ключи сравниваются через `hashCode()` и `equals()`;
		- при совпадении – значение перезаписывается;
		- иначе элемент добавляется в конец списка или дерева. 
4. если `size > threshold`, вызывается `resize()` (удвоение размера + перехеширование).

Весь цикл вставки:

![[Resources/Collections/800.jpeg]]

Алгоритм работы при получении элементов: 
1. вычисление хеша ключа;
2. поиск в бакете:
	- если элемент один – проверка ключа;
	- если список/дерево – последовательный обход. 
3. для деревьев используется `getTreeNode()` с поиском по хешам и `compareTo()`. 

Условия для дерева: 
- если в бакете ≥8 элементов и размер таблицы ≥64, список преобразуется в красно-черное дерево (для сохранения производительности `O(log n)`); 
- балансировка дерева происходит при вставке/удалении;
- при уменьшении элементов в бакете до 6 дерево преобразуется обратно в список. 

Красно-черное дерево:

![[Resources/Collections/800 1.jpeg]]

Красно-черное дерево в `HashMap`:

![[Resources/Collections/800-1.jpeg]]

Важные особенности:
- порядок элементов не гарантируется;
- инициализация таблицы происходит при первом `put()`; 
- null-ключи хранятся в бакете `0`. 

Производительность: 
- в среднем: O(1) для `put()`, `get()`, `remove()`;
- в худшем случае (все элементы в одном бакете): O(n) для списка, O(log n) для дерева. 

### TreeMap

TreeMap — реализация интерфейса `NavigableMap`, хранящая элементы в отсортированном порядке. Основана на красно-чёрном дереве, что обеспечивает сортировку и логарифмическое время доступа.
 
Сравнение `TreeMap`, `HashMap` и `LinkedHashMap`:

| Свойство | HashMap | LinkedHashMap | TreeMap |
| ----------------------- | --------- | -------------------- | ------------------------------------------ |
| Порядок хранения | Случайный | В порядке добавления | В порядке возрастания (или по компаратору) |
| Время доступа | O(1) | O(1) | O(log(n)) |
| Интерфейсы | Map | Map | NavigableMap, SortedMap, Map |
| Структура данных | Корзины | Корзины | Красно-чёрное дерево |
| Поддержка `null` ключей | Да | Да | Только с компаратором |
| Потокобезопасность | Нет | Нет | Нет |

Основные характеристики красно-чёрного дерева:
- каждый узел окрашен в красный или чёрный цвет;
- корень всегда чёрный;
- все листья (null-узлы) считаются чёрными;
- если узел красный, то оба его дочерних узла — чёрные (нет двух красных подряд);
- на любом пути от узла до листа число чёрных узлов одинаково (чёрная высота).

Цвета используются для поддержания баланса дерева во время операций вставки и удаления:
- балансировка гарантирует, что дерево не превратится в "вырожденный" список;
- это позволяет сохранять логарифмическую сложность операций.

Строение:
- каждый элемент — это узел дерева;
- узлы связаны бинарными ссылками: левый ребёнок хранит ключи меньше текущего, правый ребёнок — больше;
- благодаря этому упорядоченному размещению можно быстро искать нужный ключ, сравнивая его с текущим узлом и переходя налево или направо.

### ConcurrentModificationException

Если коллекция изменяется во время итерации (например, с помощью `iterator()`), а она не поддерживает модификации на ходу (например, `ArrayList`).

Исключение не возникает:
- при использовании методов, вроде `putIfAbsent()`, у потокобезопасных коллекций (`ConcurrentHashMap` и др.);
- при вызове `size()` на коллекции, модифицированной параллельно, может быть возвращено неточное значение.

Особенности ConcurrentHashMap:
- потокобезопасная реализация `Map`, добавлена в JDK 1.5;
- имеет высокую степень параллелизма по сравнению с `Collections.synchronizedMap`;
- внутри разделена на сегменты (до JDK 1.8) или таблицы/бинов (после JDK 1.8);
- при блокировке изменяется только нужный сегмент или корзина, а не вся структура (мелкозернистая блокировка → высокая масштабируемость).

---
## Принцип Fail Fast!

Есть три подхода к ошибкам:
- Ignore! — игнорировать ошибки (плохо, опасно);
- Fail Fast! — немедленно остановить работу при ошибке (лучше на этапе разработки);
- Fail Safe! — обработать ошибку и продолжить работу (важно в критичных системах и продакшене).

Польза Fail Fast для качества кода:
- позволяет быстро обнаруживать и исправлять ошибки на ранних этапах;
- снижает затраты на отладку и поддержку;
- помогает писать более надёжный код;
- предотвращает серьёзные сбои и катастрофы в продакшене.

Рекомендации по применению Fail Fast:
- на этапе разработки — применять всегда;
- в продакшене — по умолчанию применять, кроме критических систем (медицина, банки, космос), где важна отказоустойчивость и минимизация ущерба (там используют Fail Safe или гибридные подходы).

---
## Исключения

Типы ошибок:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXco609zdesmg0o9BawGeJ20ZJJOOc1_cUWyx3OADcyZCTF_XCJbJZEiq7-5rqKQ_StzNDN141U0JJNufWZ7g1DLZ74rgXw9RNp2Mzrj5l6FuiDEoO-p6GT6-L6kdLkUtsTqe7cFLyVTG_lNc8kkkjyVbss?key=GLq7sYVjQHhGxwbWqwq00w)

Блок `finally` всегда выполняется перед оператором `return` из других блоков, поэтому он может вернуть значение раньше, чем будет выброшена ошибка. Однако `finally` не выполнится в следующих случаях:
- произойдет завершение работы JVM, например, при вызове `System.exit(0)` или при остановке системы (halt);
- возникнет критическая ошибка, которую JVM не в состоянии обработать, например, `StackOverflowError` или `OutOfMemoryError`;
- в блоках `try` или `catch` возникнет бесконечный цикл, из-за которого поток не сможет дойти до `finally`;
- если поток является daemon-потоком, который может быть завершён JVM без выполнения `finally`.

Конструкция `try-with-resources` предназначена для автоматического закрытия ресурсов после использования. Работает с ресурсами, реализующими интерфейс `AutoCloseable` (например, файлы, потоки, соединения с базой данных). Решает следующие проблемы:
- позволяет избежать типичных ошибок — забыть закрыть ресурс;
- автоматически вызывает метод `close()` у ресурса после выхода из блока `try`;
- можно использовать несколько ресурсов через точку с запятой.

Синтаксис:

```java
try (ResourceType resource = new ResourceType()) {

} // ресурс автоматически закрывается здесь, даже если было исключение
```

UncaughtExceptionHandler — интерфейс, который обрабатывает исключения, не пойманные в блоках `try-catch` внутри потоков (threads). Этот механизм помогает регистрировать ошибки, а также выполнять аварийное завершение или предпринимать действия по восстановлению.

Главный метод `void uncaughtException(Thread t, Throwable e)` — вызывается, когда в потоке `t` возникает исключение, не пойманное в коде.

Использование:
- назначить обработчик для конкретного потока можно через `thread.setUncaughtExceptionHandler(handler);`
- задать обработчик по умолчанию для всех потоков — через `Thread.setDefaultUncaughtExceptionHandler(handler);`

---
## Базовая многопоточность 

`Thread Dump` — это снимок всех потоков, запущенных в JVM в определённый момент времени. Он показывает их состояние, стек вызовов и может помочь найти причины зависаний, утечек, блокировок и других проблем.

Используется для следующих сценариев:
- при анализе "зависших" приложений;
- при поиске deadlock'ов;
- при оптимизации многопоточности;
- при анализе производительности.

Содержит:
- имя потока;
- статус: `RUNNABLE`, `WAITING`, `TIMED_WAITING`, `BLOCKED`;
- стек вызовов (stack trace);
- информация о блокировках (мониторах).

Пример:

```text
"main" #1 prio=5 os_prio=31 tid=0x00007ffee5b0c000 nid=0x1a03 runnable [0x0000700000c37000]
 java.lang.Thread.State: RUNNABLE
 at com.example.MyClass.method(MyClass.java:42)
```

`ThreadLocal<T>` — это специальный класс, позволяющий каждому потоку хранить собственное значение переменной. То есть, каждый поток работает со своей копией.

Нужен по следующим причинам:
- изоляция данных между потоками;
- хранение пользовательских сессий, транзакций, контекста;
- работа с не-потокобезопасными объектами (например, `SimpleDateFormat`).

Пример:

```java
public class MyClass {
  private static final ThreadLocal < Integer > threadLocal = ThreadLocal.withInitial(() -> 0);

  public void increment() {
    threadLocal.set(threadLocal.get() + 1);
  }

  public int get() {
    return threadLocal.get();
  }
}
```

Особенности:
- значение `ThreadLocal` доступно только в текущем потоке;
- утечки памяти возможны при неправильном использовании (например, в `ThreadPool`);
- удаление значения вручную `threadLocal.remove()`.

Различие между `Callable` и `Runnable`:
1. `Callable` реализует метод `call()`, тогда как `Runnable` реализует метод `run()`;
2. `Callable` способен возвращать результат выполнения, в отличие от `Runnable`, который не возвращает значения;
3. `Callable` может выбрасывать проверяемые исключения (`checked exceptions`), а `Runnable` — нет;
4. `Callable` можно использовать с методами `invokeAny()` и `invokeAll()` интерфейса `ExecutorService`, тогда как `Runnable` с ними не совместим.

### Executors

Java предлагает фабричные методы в классе `Executors` для создания различных видов пулов потоков:
- `newSingleThreadExecutor()` — пул с одним потоком;
- `newFixedThreadPool(int nThreads)` — пул с фиксированным числом потоков;
- `newCachedThreadPool()` — динамически растущий пул, повторно использующий потоки;
- `newScheduledThreadPool(int corePoolSize)` — пул с поддержкой планирования задач по времени.

Лучше не создавать потоки вручную через `new Thread(() -> {})` по следующим причинам:
- количество потоков в системе ограничено (например, около 4000 на macOS), при превышении этого лимита — `OutOfMemoryError`, независимо от доступной памяти;
- каждый поток требует ресурсов ОС и процессора — запуск новых потоков "с нуля" дорог по времени и памяти.

До Java 19 чтобы автоматически закрыть `ExecutorService`, можно использовать `try-with-resources`, но только с обходными путями:

```java
ExecutorService service = Executors.newSingleThreadExecutor();
try (AutoCloseable close = service::shutdown) {
 // Работаем с пулом
}
```

Чтобы избежать `throws Exception` от `AutoCloseable.close()`, можно сделать интерфейс:

```java
interface MyCloseable extends AutoCloseable {
  void close(); // без checked exception
}
```

Однако этот способ ограничен:
- нельзя вставлять код между созданием `service` и `try`;
- нельзя использовать `service` после блока `try`.

Начиная с Java 19 `ExecutorService` теперь реализует `AutoCloseable`. Теперь при закрытии:
- вызывается `shutdown();
- ожидается завершение задач (`awaitTermination()`);
- при прерывании вызывается `shutdownNow()`.

### CAS (Compare And Swap)

CAS — неблокирующий механизм обновления значения переменной, который используется в `Atomic` классах. Применяется в `AtomicInteger`, `ConcurrentHashMap`, `CopyOnWriteArrayList` и др. Работает по схеме:
1. сравнивает текущее значение с ожидаемым;
2. если совпадает — меняет значение;
3. иначе — повторяет попытку.

Различие между мьютекс и монитор заключается в следующем:
- в Java термин монитор означает встроенный механизм синхронизации (`synchronized`);
- мьютекс (mutual exclusion) — более общий термин из многопоточности;
- в контексте Java монитор = мьютекс, реализованный на уровне JVM.

Жизненный цикл потока:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXetQtJFREnWn8EcYwFMwgTu7Jb9Nvp5EBWwoeJX-6LgphoGVOATuGdFM7OaQBzRl-kZHiShQBS2HyG4giIbmUPPtANIIlx1F2Mo3JX9pTc0BQ5LiBhaiHQNAwFzYygKtmnnuKFyeqlB36M8xXpSoLjNzj6B?key=GLq7sYVjQHhGxwbWqwq00w)

В основе многопоточности лежат два ключевых понятия — потоки и процессы, давайте их рассмотрим:

Процесс — это экземпляр выполняющейся программы. Каждый процесс обладает своим собственным адресным пространством и ресурсами, такими как файлы и сетевые соединения. По сути это изолированный контейнер, в котором выполняется код программы.

Поток (или поток выполнения) — более легковесная единица выполнения, существующая внутри процесса. В одном процессе может существовать несколько потоков, которые могут параллельно выполнять инструкции программы. В отличие от процессов, потоки внутри одного процесса совместно используют его ресурсы. Есть и другие варианты решения проблем взаимной блокировки и состояния гонки, которые также используют несколько фундаментальных понятий. Поэтому давайте проясним эти понятия. 

Синхронизация — это процесс управления одновременным выполнением нескольких потоков или процессов с целью предотвращения возможных конфликтов и проблем, связанных с одновременным доступом к общим ресурсам.

Монитор — это механизм синхронизации, связанный с каждым объектом. Он обеспечивает взаимное исключение и контроль доступа к общим ресурсам. Только один поток может находиться в мониторе объекта в любой момент времени. Мониторы используются для предотвращения состояний гонки и обеспечивают безопасное взаимодействие между потоками.

Критическая секция — участок кода, в котором выполняются операции над общими ресурсами. Внутри критической секции поток захватывает монитор объекта, чтобы гарантировать взаимное исключение.

Synchronized — это ключевое слово в Java, которое используется для синхронизации потоков. Когда метод или блок кода помечается как synchronized, это означает, что только один поток может выполнять данный метод или блок кода на объекте в определенный момент времени.

Потоки делают следующее:
- повышение производительности (распределение задач); 
- улучшение отзывчивости (неблокирующий UI); 
- оптимизация пользовательского опыта. 

Преимущества многопоточности:
- конкурентность и параллелизм; 
- масштабируемость; 
- отказоустойчивость (сбой в одном потоке ≠ крах приложения). 

Ключевые механизмы синхронизации:
- `synchronized` – гарантирует, что только один поток выполняет блок/метод. Решает проблему Race Condition. 

Синтаксис:

 ```java
 public synchronized void increment() { counter++; }
 ```

- `volatile` – обеспечивает видимость изменений переменной для всех потоков. 

Синтаксис:

 ```java
 private volatile boolean flag = false;
 ```
 
- Монитор и критические секции – контроль доступа к общим ресурсам. 

### Способы создания потоков

#### 1. Наследование от `Thread` 

Синтаксис:

```java
class MyThread extends Thread {
  public void run() {
    /* код */ }
}
MyThread t = new MyThread();
t.start();
```

Методы: 
- `sleep()` – приостановка потока. 
- `join()` – ожидание завершения потока. 
- `yield()` – передача управления другим потокам. 

#### 2. Реализация `Runnable` 

Синтаксис:

```java
class MyRunnable implements Runnable {
  public void run() {
    /* код */ }
}
Thread t = new Thread(new MyRunnable());
t.start();
```

Плюсы: гибкость (нет ограничения наследования). 

#### 3. Интерфейс `Callable` + `Future` 

Данный интерфейс возвращает результат и бросает исключения. 

Синтаксис:

```java
Callable < Integer > task = () -> {
  return 42;
};
ExecutorService executor = Executors.newSingleThreadExecutor();
Future < Integer > future = executor.submit(task);
Integer result = future.get(); // блокирующий вызов
```

#### 4. `CompletableFuture` (Java 8+) 

Представляет собой асинхронные цепочки вычислений. 

Синтаксис:

```java
CompletableFuture.supplyAsync(() -> "Hello")
  .thenApply(s -> s + " World")
  .thenAccept(System.out::println);
```

#### 5. `Executors` и пулы потоков 

Синтаксис:

```java
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(() -> { /* задача */ });
executor.shutdown();
```

Есть несколько пулов:
- `FixedThreadPool` – фиксированное число потоков; 
- `CachedThreadPool` – масштабируемый пул;
- `ForkJoinPool` – для рекурсивных задач (разделяй и властвуй). 

Синтаксис:

```java
class MyTask extends RecursiveAction {
 protected void compute() { /* разделение задачи */ }
}
ForkJoinPool pool = new ForkJoinPool();
pool.invoke(new MyTask());
```

#### 6. `Parallel Stream` 

Параллельная обработка коллекций. 

Синтаксис:

```java
list.parallelStream().map(x -> x * 2).forEach(System.out::println);
```

#### 7. Атомарные классы (`AtomicInteger`, etc.) 

Атомарные операции без блокировок (CAS-механизм). 

Синтаксис:

```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet();
```

### Проблемы многопоточности

Существует несколько проблем многопоточности:
1. Race Condition (Состояние гонки) – это недостаток в системе, который проявляется в различных результатах в зависимости от последовательности действий участников системы (Решение: `synchronized`, атомарные классы);
2. Deadlock – взаимная блокировка потоков (Решение: Упорядоченное получение блокировок, `tryLock()`);
3. Livelock – потоки "вежливо" мешают друг другу;
4. Starvation – поток не получает ресурсы из-за жадных соседей.

Пример Deadlock:

```java
public class DeadlockExample {
  private final Object lock1 = new Object();
  private final Object lock2 = new Object();

  public void method1() {
    synchronized(lock1) {
      System.out.println("Thread 1: Holding lock1...");
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized(lock2) {
        System.out.println("Thread 1: Holding lock1 & lock2...");
      }
    }
  }

  public void method2() {
    synchronized(lock2) {
      System.out.println("Thread 2: Holding lock2...");
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized(lock1) {
        System.out.println("Thread 2: Holding lock2 & lock1...");
      }
    }
  }

  public static void main(String[] args) {
    DeadlockExample example = new DeadlockExample();

    Thread t1 = new Thread(example::method1);
    Thread t2 = new Thread(example::method2);

    t1.start();
    t2.start();
  }
}
```

---
## Пакет `java.util.concurrent`

Пакет `java.util.concurrent` включает классы и интерфейсы для многопоточного программирования, разделённые на функциональные группы:

### 1. Concurrent Collections

Потокобезопасные аналоги коллекций из `java.util`:
- [[CopyOnWriteArrayList]] — потокобезопасный `ArrayList`. При изменении создаёт новую копию массива.
- [[ConcurrentHashMap]] — аналог `HashMap` с сегментированной структурой для параллельного доступа.
- [[CopyOnWriteArraySet]] — реализация `Set` на основе `CopyOnWriteArrayList`.
- ConcurrentSkipListMap/SkipListSet — аналоги `TreeMap` и `TreeSet` с поддержкой многопоточности.

Особенности:
- итераторы работают с "моментальным снимком" данных;
- не вызывают `ConcurrentModificationException`.

### 2. Synchronizers

Альтернативы базовой синхронизации (`synchronized`, `wait/notify`):
- [[Resources/Concurrent/Semaphore|Semaphore]] — ограничивает количество потоков, обращающихся к ресурсу.

Визуализация:

![[Resources/Concurrent/concurrent-semaphore.gif]]

- [[Resources/Concurrent/CountDownLatch|CountDownLatch]] — блокирует потоки до выполнения заданного числа условий.

Визуализация:

![[Resources/Concurrent/concurrent-countdownlatch.gif]]

- [[Resources/Concurrent/CyclicBarrier|CyclicBarrier]] — синхронизирует потоки в точке "барьера" (многоразовый).

Визуализация:

![[Resources/Concurrent/concurrent-cyclebarrier.gif]]

- [[Resources/Concurrent/Exchanger|Exchanger]] — обмен данными между двумя потоками.

Визуализация:

![[Resources/Concurrent/concurrent-exchanger.gif]]

- [[Resources/Concurrent/Phaser|Phaser]] — расширенный `CyclicBarrier` с поддержкой фаз.

Визуализация:

![[Resources/Concurrent/concurrent-phaser.gif]]

### 3. Atomic Classes

Классы для атомарных операций (без блокировок). Примеры: `AtomicInteger`, `AtomicReference`, `AtomicBoolean`.

Метод `compareAndSet` — меняет значение, только если оно соответствует ожидаемому (CAS-операция).

Применение: счётчики, флаги, обновление ссылок.

### 4. Queues

Неблокирующие (высокая производительность):
- `ConcurrentLinkedQueue` — FIFO-очередь на CAS;
- `ConcurrentLinkedDeque` — двунаправленная очередь.

Блокирующие (контроль перегрузки):
- `ArrayBlockingQueue` — очередь на массиве с фиксированной ёмкостью;
- `LinkedBlockingQueue` — очередь на связанных узлах (по умолчанию — неограниченная);
- `PriorityBlockingQueue` — очередь с приоритетами;
- `SynchronousQueue` — "точка обмена" между потоками;
- `DelayQueue` — элементы извлекаются после задержки.

### 5. Locks

Альтернативы `synchronized`:
- `Lock` — интерфейс для гибкой блокировки (например, `ReentrantLock`);
- `Condition` — аналог `wait/notify` для `Lock`;
- `ReadWriteLock` — разделяет блокировки на чтение (`readLock`) и запись (`writeLock`).

Преимущество — возможность использовать таймауты, прерывания и неблокирующие попытки.

### 6. Executors

Интерфейсы:
- `Callable` — аналог `Runnable` с возвращаемым значением;
- `Future` — результат асинхронной задачи (метод `get` блокирует поток);
- `ExecutorService` — управление пулами потоков (методы `submit`, `invokeAll`);
- `ScheduledExecutorService` — планирование задач (`ScheduledThreadPoolExecutor`).

Реализации:
- `ThreadPoolExecutor` — пул потоков с настройкой;
- `ForkJoinPool` — для задач типа "разделяй и властвуй".

Класс `Executors` — фабрики для создания пулов.

---
## JMM

Области памяти в куче:

![[Resources/JMM/image.png.webp]]

Гипотеза о поколениях:
- большинство объектов живут очень недолго;
- чем дольше объект существует, тем выше вероятность, что он будет жить дальше.

Поколения:
- Young Generation (младшее поколение) — короткоживущие объекты;
- Old Generation (старшее поколение) — долгоживущие объекты.

Типы сборок мусора:
- Minor GC — очищает Young Generation (быстро, выполняется часто);
- Full GC — очищает всю кучу (медленно, выполняется редко).

Критерии оценки сборщиков мусора:
- максимальная задержка (STW — Stop-The-World) — время, на которое программа приостанавливается;
- пропускная способность — отношение времени работы программы к времени сборки мусора;
- потребляемые ресурсы — CPU и память, используемые сборщиком.

Объект считается мертвым, если до него нельзя добраться из корней (корни — статические поля, локальные переменные в стеках и т. д.). Проблема: объекты из Young Generation могут удерживаться ссылками из Old Generation (ложное "бессмертие").

Мониторинг при помощи внутренних инструментов (встроенные в JVM):
- логирование через флаги:
 - `-verbose:gc` — базовый вывод;
 - `-Xloggc:filename` — запись в файл;
 - `-XX:+PrintGCDetails` — детализация;
 - `-XX:+PrintGCTimeStamps` — временные метки.
- использование MXBean для программного мониторинга.

Мониторинг при помощи внешних инструментов: VisualVM, Java Mission Control, JProfiler, YourKit и др. Проблема: инструменты могут влиять на работу программы (например, создавать дополнительную нагрузку).

### Модель памяти

В многопроцессорных системах процессоры используют кэши для производительности, что создает проблемы с согласованностью данных (когда разные процессоры видят одну и ту же ячейку памяти).

МП на уровне процессора определяет условия видимости записей в память другими процессорами. Типы:
- сильные МП: все процессоры видят одинаковые значения;
- слабые МП: требуют барьеров памяти (memory barriers) для синхронизации кэшей (часто при lock/unlock). 
Современные процессоры склоняются к слабым МП для масштабируемости.

Компиляторы и процессоры могут изменять порядок операций для оптимизации. Это не влияет на однопоточные программы (as-if-serial), но критично для многопоточных. Пример: `writer {x=1; y=2;}` и `reader {r1=y; r2=x;}`. Если `reader` видит `y=2`, это не гарантирует, что он увидит `x=1` (записи могли быть переупорядочены).

Java Memory Model описывает легальное поведение многопоточного кода, взаимодействие потоков через память, и как низкоуровневые операции (сохранение/извлечение из памяти/регистров) соотносятся с переменными. JMM позволяет корректно реализовать Java на разных архитектурах с разными оптимизациями.

Конструкции Java (`volatile`, `final`, `synchronized`) помогают программисту указать требования к параллелизму. JMM определяет их поведение и гарантирует корректность правильно синхронизированных программ.

### JSR 133

Проблемы старой JMM (до Java 5):
- серьезные недостатки (например, `final` поля могли "менять" значения);
- мешала стандартным оптимизациям компилятора;
- была сложна для понимания и часто нарушалась реализациями JVM;
- `final`-поля: вопреки ожиданиям, требовали синхронизации для гарантированной видимости их значений другим потокам, неизменяемые объекты (например, `String`) могли "казаться" изменяемыми;
- `volatile`-поля: допускалось переупорядочение операций с `volatile` и обычными переменными, что противоречило интуиции.

JSR 133 (New JMM) — определяет новую модель памяти, исправляющую недостатки старой. Изменены семантики `final` и `volatile`.

Цели JSR 133:
- сохранение гарантий безопасности (type safety) и усиление других (значения не "из воздуха");
- простая и интуитивная семантика для корректно синхронизированных программ;
- определенная семантика для некорректно синхронизированных программ (минимизация угроз);
- возможность уверенно рассуждать о взаимодействии потоков с памятью;
- возможность создания корректных и высокопроизводительных JVM;
- новая гарантия безопасной инициализации: если объект правильно сконструирован (без утечки `this` в конструкторе), все потоки, видящие ссылку на объект, увидят значения `final`-полей, установленные в конструкторе, без дополнительной синхронизации;
- минимальное влияние на существующий код.

Концепция 'happens before' описывает отношения между различными операциями в многопоточной программе. В Java она определяется в спецификации Java Memory Model (JMM). 

#### Основные правила 'happens before'

1. Программный порядок: в одном потоке все операции выполняются в том порядке, в котором они написаны в коде. Это означает, что если в одном потоке сначала выполняется операция A, а затем операция B, то операция A всегда будет завершена до начала операции B. 
2. Блокировка монитора: разблокировка монитора в одном потоке происходит до последующей блокировки того же монитора в другом потоке. Это правило гарантирует, что критические секции кода, защищенные синхронизацией, выполняются последовательно и не пересекаются.
3. Взаимодействие через `volatile` переменные: запись в `volatile` переменную происходит до последующего чтения этой переменной другим потоком. Это обеспечивает видимость изменений, сделанных одним потоком, для других потоков.
4. Создание и завершение потоков: создание потока происходит до начала его выполнения, а завершение потока происходит до того, как другой поток обнаружит его завершение. Это правило помогает управлять жизненным циклом потоков и их взаимодействием.
5. Передача данных через `join()`: вызов метода `Thread.join()` на одном потоке происходит до завершения этого потока. Это позволяет одному потоку дождаться завершения другого потока перед продолжением выполнения.

---
## Типы GC

### 1. Serial GC

Визуализация работы GC:

![[Resources/JMM/GC-Serial-Type.png]]

Принцип работы:
- Minor GC (малая сборка):
	- очищает Eden и один из Survivor (копирует выжившие объекты в другой Survivor);
	- если объект выживает несколько сборок, он переходит в Old Generation.
- Full GC (полная сборка):
	- очищает всю кучу (Young + Old);
	- использует алгоритм Mark-Sweep-Compact (пометить → удалить → уплотнить).

Основные характеристики:
- однопоточный, работает последовательно;
- подходит для маленьких куч (до ~100 МБ) и одноядерных систем;
- включается флагом: `-XX:+UseSerialGC`.
 
Куча делится на 4 региона:
1. Young Generation (младшее поколение):
	- Eden — здесь создаются новые объекты;
	- Survivor 0 и Survivor 1 — сюда перемещаются выжившие после сборки объекты.
2. Old Generation (Tenured) — сюда попадают долгоживущие объекты.

Настройки:
- `-Xms` / `-Xmx` — минимальный и максимальный размер кучи;
- `-XX:NewRatio` — соотношение Old/Young (по умолчанию `2`, т. е. Old в 2 раза больше Young);
- `-XX:SurvivorRatio` — соотношение Eden/Survivor (по умолчанию `8`, т. е. Eden = 80% Young);
- `-XX:+PrintTenuringDistribution` — статистика по выживанию объектов.
 
Плюсы и минусы:
- плюсы: простота реализации;
- минусы: долгие паузы Stop-The-World.

### 2. Parallel GC

Визуализация работы GC:

![[Resources/JMM/GC-Parallel-Type.png]]
 
 ### Основные характеристики:
- многопоточный, использует несколько ядер CPU;
- стандартный сборщик для многоядерных систем (если не указан другой);
- включается флагом: `-XX:+UseParallelGC`.

Отличия от Serial GC:
1. параллельная обработка:
	- Minor и Full GC выполняются в нескольких потоках;
	- уменьшает STW-паузы.
2. автоматическая подстройка: может динамически менять размеры регионов, чтобы уменьшить задержки или увеличить пропускную способность.

Настройки:
- `-XX:ParallelGCThreads` — количество потоков для GC (по умолчанию = числу ядер CPU);
- `-XX:MaxGCPauseMillis` — максимально допустимая пауза (например, `-XX:MaxGCPauseMillis=100`);
- `-XX:GCTimeRatio` — целевая пропускная способность (например, `-XX:GCTimeRatio=99` означает, что GC должен занимать ≤1% времени);
- `-XX:+UseParallelOldGC` — включает параллельную сборку в Old Generation (по умолчанию включено).
 
Плюсы и минусы:
- плюсы: быстрее Serial GC, автоматическая оптимизация. 
- минусы:
	- фрагментация памяти (из-за параллельного копирования);
	- не подходит для low-latency приложений (например, реального времени).

### 3. CMS (Concurrent Mark Sweep)

Визуализация работы GC:

![[Resources/JMM/GC-CMS-type.png]]

Основные характеристики:
- конкурентный сборщик, минимизирует STW-паузы;
- подходит для приложений с большими кучами, чувствительных к задержкам;
- включается флагом: `-XX:+UseConcMarkSweepGC`.

Организация кучи аналогична Serial/Parallel GC:
- Young Generation (Eden + Survivor 0 + Survivor 1);
- Old Generation (Tenured) — здесь работает конкурентная сборка.

Принцип работы:
1. Minor GC (STW): очищает Young Generation, выжившие объекты переносятся в Tenured.
2. Major GC (Concurrent Mark-Sweep):
	- Initial Mark (STW) — короткая пауза, помечает корневые объекты;
	- Concurrent Mark — поиск живых объектов параллельно с приложением;
	- Remark (STW) — уточнение списка живых объектов;
	- Concurrent Sweep — удаление мусора без уплотнения (может вызывать фрагментацию).

Настройки:
- `-XX:CMSInitiatingOccupancyFraction=70` — запускать сборку при заполнении Old Gen на 70%.
- `-XX:+UseCMSInitiatingOccupancyOnly` — не менять порог автоматически.
- `-XX:+CMSScavengeBeforeRemark` — выполнять Minor GC перед Remark (уменьшает STW).

Проблемы CMS:
- фрагментация Old Generation (нет уплотнения);
- плавающий мусор (объекты, удаляемые только в следующей сборке);
- Concurrent Mode Failure — если сборка не успевает, происходит полный STW (как в Serial GC).

Плюсы и минусы:
- плюсы: меньшие STW-паузы, чем у Parallel GC. 
- минусы:
	- фрагментация, высокие накладные расходы на CPU; 
	- устарел, заменяется на G1 GC.

### 4. G1

Визуализация работы GC:

![[Resources/JMM/g1-gc-heap.jpg]]

Основные характеристики:
- современный сборщик, замена CMS;
- работает с большими кучами (от 4 ГБ+), минимизирует паузы;
- включается флагом: `-XX:+UseG1GC`.
 
Куча разделена на регионы (обычно 1–32 МБ):
- нет фиксированных Eden/Survivor/Tenured — регионы динамически меняют назначение;
- Humongous Regions — для очень больших объектов (>50% региона).

Принцип работы
1. Young GC (STW):
	- очищает часть регионов Young Gen (выбирает самые "мусорные");
	- использует несколько потоков.
2. Mixed GC (STW + Concurrent):
	- цикл пометки (Concurrent Marking):
	- Initial Mark (STW) — корневые объекты;
	- Concurrent Mark — поиск живых объектов;
	- Remark (STW) — уточнение;
	- Cleanup (частично STW) — освобождение пустых регионов.
	- затем Mixed GC — очищает Young + часть Old Gen.
3. Full GC (STW, только если не хватает памяти).

Особенности:
- Garbage-First — выбирает регионы с максимумом мусора;
- автоматическая настройка под целевое время паузы (`MaxGCPauseMillis`);
- меньше фрагментации, чем у CMS.

Настройки:
- `-XX:MaxGCPauseMillis=200` — целевое время паузы (по умолчанию ~200 мс);
- `-XX:G1HeapRegionSize=16m` — размер региона (степень двойки);
- `-XX:InitiatingHeapOccupancyPercent=45` — запуск цикла пометки при заполнении кучи на 45%;
- `-XX:ParallelGCThreads=8` — потоки для Young GC;
- `-XX:ConcGCThreads=4` — потоки для Concurrent Marking.

Плюсы и минусы:
- плюсы: меньше фрагментации, чем у CMS. 
- минусы:
	- выше накладные расходы (CPU) по сравнению с Parallel GC; 
	- проблемы с Humongous Objects (большие объекты не удаляются в Young GC).

### 5. Epsilon GC

Основные характеристики:
- никакой сборки мусора — память не освобождается;
- завершает работу, как только заканчивается доступная куча (`OutOfMemoryError`);
- полезен для тестирования и приложений с контролируемым временем жизни;
- включается флагами:
	- `-XX:+UnlockExperimentalVMOptions`;
	- `-XX:+UseEpsilonGC`.
- добавлен в JDK 11 как экспериментальный (и таким останется).

Принцип работы:
- использует TLAB (thread-local allocation buffers) для быстрой, неблокирующей аллокации;
- потоки получают выделенные буферы в куче — без синхронизации;
- крупные объекты (humongous) размещаются отдельно;
- при исчерпании памяти немедленно выбрасывает `OutOfMemoryError`, не пытаясь освободить объекты.

Настройки:
- `-XX:+EpsilonElasticTLAB` — разрешает динамически изменять размер TLAB;
- `-XX:EpsilonTLABElasticity=<N>` — степень "эластичности" буфера;
- `-XX:+EpsilonElasticTLABDecay` — включает постепенное возвращение размера TLAB к начальному;
- `-XX:EpsilonTLABDecayTime=<time>` — интервал сброса буфера;
- `-XX:EpsilonMaxTLABSize=<size>` — максимальный размер TLAB;
- `-XX:EpsilonMinHeapExpand=<size>` — минимальный прирост размера кучи.
 
Плюсы и минусы:
- плюсы:
	- никаких накладных расходов на сборку мусора;
	- отсутствие барьеров доступа и потоков GC;
	- максимально предсказуемое поведение.
- минусы:
	- быстрое заполнение памяти;
	- фрагментация и отсутствие повторного использования памяти;
	- возможное замедление доступа к объектам.

Сценарии использования
1. приложения, в которых гарантировано не создаётся мусора;
2. краткоживущие задачи и тесты производительности;
3. отладка или стресс-тестирование поведения памяти.

### 6. ZGC

ZGC — сборщик мусора для Java HotSpot VM, с JDK 15 — production ready.

Основные характеристики:
- паузы Stop-the-World менее 1 миллисекунды;
- паузы не увеличиваются с ростом размера кучи и количества живых объектов;
- поддержка куч размером до 16 ТБ;
- включается флагом:
	- `-XX:UseZGC`;
	- В JDK 11-13 дополнительно: `-XX:+UnlockExperimentalVMOptions`.

Принцип работы:
- использует возможности виртуальной памяти — разные виртуальные адреса могут указывать на одну физическую страницу;
- применяет цветные указатели (colored pointers) с 4 битами метаданных;
- метки указывают состояние объекта и позволяют менять виртуальные адреса без перемещения данных;
- барьеры выполняются в потоках приложения и обновляют указатели при доступе к объектам;
- сборка делится на фазы: поиск живых объектов, перемещение, переадресация.

Настройки:
- `-XX:ZFragmentationLimit=percent` — порог фрагментации для перемещения памяти;
- `-XX:ZCollectionInterval=seconds` — максимальный интервал между сборками;
- `-XX:ZAllocationSpikeTolerance=factor` — допускаемые всплески аллокаций;
- `-XX:+ZProactive` — проактивный режим сборки;
- `-XX:ZUncommit` и `-XX:ZUncommitDelay` — возврат памяти ОС;
- `-XX:ConcGCThreads=threads` — число потоков сборки.

Плюсы и минусы:
- плюсы:
	- субмиллисекундные паузы Stop-the-World;
	- паузы не зависят от размера кучи;
	- поддержка очень больших куч (до 16 ТБ);
	- подходит для приложений с чувствительностью к задержкам.
- минусы:
	- дополнительные накладные расходы на барьеры;
	- требует больше памяти для избежания полных сборок;
	- при интенсивном создании объектов нужна большая куча.

Сценарии использования:
1. приложения, критичные к задержкам;
2. приложения с очень большими кучами;
3. системы, где важна предсказуемость пауз, а не максимальная пропускная способность.

### 7. Shenandoah GC

Визуализация работы GC:

![[Resources/JMM/0_tCac0U_wvDjw7Tdj.webp]]

Общая информация:
- тип: конкурентный, low-latency;
- цель: короткие паузы даже на больших кучах (десятки ГБ+);
- аналоги: ZGC (отличается реализацией);
- доступность:
	- Входит в OpenJDK с версии 12;
	- Порты для JDK 11 (Amazon, Azul, Adoptium) и JDK 8 (Red Hat).
- включается флагом: `-XX:+UseShenandoahGC`.

Ключевые особенности:
- Brooks Pointers — каждый объект содержит дополнительный указатель для конкурентного перемещения без длинных пауз;
- куча разбита на фиксированные регионы (обычные и humongous);
- динамическое перераспределение регионов между Eden, Survivor и Old Gen;
- низкие накладные расходы на барьеры.

Режимы работы при нехватке ресурсов:
- Pacing — замедление аллокации, чтобы GC догнал приложение;
- Degenerated GC — часть фаз выполняется в STW для сохранения коротких пауз;
- Full GC — полная остановка приложения (крайний случай).

Фазы работы Shenandoah:
1. Init Mark (STW) — короткая пауза, пометка корней;
2. Concurrent Marking — конкурентный обход кучи с использованием SATB;
3. Final Mark (STW) — уточнение живых объектов и выбор регионов;
4. Concurrent Evacuation — конкурентное перемещение объектов с помощью барьеров;
5. Init Update Refs (STW) — синхронизация перед обновлением ссылок;
6. Concurrent Update Refs — обновление ссылок на перемещённые объекты;
7. Final Update Refs (STW) — финальная пауза, освобождение регионов.

Настройки Shenandoah:
- `-XX:ShenandoahGCMode=satb` — режим пометки (SATB по умолчанию);
- `-XX:ShenandoahGCHeuristics=adaptive` — стратегия выбора регионов для очистки;
- `-XX:ShenandoahPacingMaxDelay=10` — максимальная задержка Pacing (мс);
- `-XX:ConcGCThreads=4` — количество потоков для конкурентных фаз.

Сравнение с ZGC:

| Характеристика | Shenandoah | ZGC |
| -------------------- | ----------------------------------------------- | ------------------------------------- |
| Указатели | Brooks Pointer | Colored Pointers |
| Барьеры | Меньшие накладные расходы | Требуют больше ресурсов |
| Перемещение объектов | Конкурентное + обновление ссылок | Полностью конкурентное |
| Поддержка в JDK | С 12+ (порты для 8/11) | С 11+ (production с 15) |
| Лучше для | Средние/большие кучи, баланс latency/throughput | Очень большие кучи, ultra-low-latency |
| Generations | Нету (с jdk 21 есть) | Как в G1 |

Плюсы и минусы:
- плюсы:
	- короткие паузы даже на больших кучах;
	- плавная деградация работы (Pacing → Degenerated GC → Full GC);
	- гибкая настройка с различными эвристиками.
- минусы:
	- более высокие накладные расходы по сравнению с G1;
	- сложнее в настройке, чем Parallel GC;
	- не всегда предсказуем (как и другие low-latency GC).

Сценарии использования:
1. серверные приложения с жесткими SLA по задержкам;
2. большие кучи (10+ ГБ), когда G1 не справляется;
3. альтернатива ZGC с поддержкой JDK 8/11.

### Максимальные (и рекомендуемые) размеры хипа для разных GC

|Сборщик мусора|Поддержка размеров хипа|Комментарии|
|---|---|---|
|Serial GC|до ~100 МБ – 1 ГБ|Очень эффективен для малых хипов, например, в приложениях для IoT, CLI и т.п.|
|Parallel GC|до нескольких десятков ГБ|Хорош для крупных хипов, где важна пропускная способность.|
|CMS (устаревший)|до ~4–8 ГБ|При больших объемах могут возникать фрагментации и паузы.|
|G1 GC|от 4 ГБ до ~32–64 ГБ (и выше)|Хорош при больших объемах, настраивается для низких пауз.|
|ZGC|от ~8 ГБ до терабайтов|Спроектирован для огромных heap'ов, с низкими задержками (<10 мс).|
|Shenandoah|от ~2–4 ГБ до сотен ГБ|Поддерживает низкие паузы, работает хорошо на больших хипах.|

Разделение поколений Young Generation (примерно):
- G1 GC: обычно 1/3 от всего heap’а;
- Parallel GC: около 1/3 от всего heap’а;
- ZGC / Shenandoah: изначально не разделяют хип на поколения, но в новых версиях поддерживают это экспериментально.

Выбор GC в зависимости от объема хипа:

| Объем heap'а | Рекомендуемый GC | Причина |
| ------------ | ------------------------ | ------------------------------------------------- |
| < 512 МБ | Serial GC | Простота и эффективность |
| 1–4 ГБ | Parallel GC / G1 GC | Баланс между паузами и производительностью |
| 4–32 ГБ | G1 GC | Хорошее управление паузами |
| 32+ ГБ | G1 GC / ZGC / Shenandoah | Для минимальных задержек и больших объемов памяти |

---
## Профилирование Java-приложений и анализ проблем

Общие принципы диагностики:
- используется метод последовательного уточнения (метод Сократа): задаются уточняющие вопросы для локализации причины сбоя;
- основные источники проблем: чрезмерная загрузка CPU, переполнение Heap, проблемы с подключениями к БД;
- основные инструменты: Grafana, Prometheus, jstack, jmap, HeapDump, ThreadDump, VisualVM, Eclipse Memory Analyzer (MAT), FastThread GUI.

### 1. Действия при высокой загрузке CPU

Проверить метрики в Grafana/Prometheus: CPU Usage, JVM Thread Live, JVM Thread States, JVM Threads Daemon. Возможные причины: утечки потоков, интенсивные RUNNABLE-потоки, неправильное использование concurrency.
 
### 2. Действия при переполнение Heap (OutOfMemoryError)

Проверить метрики: JVM Heap Memory Usage, JVM GC Live Data, JVM GC Time. Цели анализа: найти объекты, удерживаемые в памяти дольше положенного, найти крупные коллекции, утечки, чрезмерное кэширование, построить Dominator Tree, посмотреть retained size.

### 3. Действия при проблемах связанных с подключениями к базе данных

Проверить метрики в Grafana: DB Connection Pool Usage, DB Connection Wait Time, DB Query Time. Если используется HikariCP — настроить параметры:
- `maximumPoolSize` — максимальное число соединений;
- `minimumIdle` — минимальное число свободных соединений;
- `connectionTimeout` — тайм-аут при получении соединения;
- `idleTimeout` — время жизни неактивного соединения;
- `maxLifetime` — общее время жизни соединения.

---
## Ссылки

Стек — это область памяти, которая работает быстро, занимает меньше места и является потокобезопасной, поскольку у каждого потока есть собственный стек.

Объекты, создаваемые в Java (и других объектно-ориентированных языках), размещаются в куче. Когда вы используете оператор `new`, память для объекта выделяется именно в куче. Все поля объекта — как примитивные типы, так и ссылки на другие объекты — хранятся в этой же области как часть самого объекта.

Переменные, которые ссылаются на объекты, чаще всего размещаются в стеке (если это локальные переменные метода) или в других областях памяти, в зависимости от контекста. Эти переменные содержат лишь ссылки на объекты, а сами объекты находятся в куче. Например, если объект содержит поле примитивного типа, его значение сохраняется непосредственно в том участке памяти кучи, который выделен для этого объекта.

---
## Автоупаковка
 
### 1. Autoboxing

Происходит в следующих случаях:
1. при присвоении значения примитивного типа переменной соответствующего класса-обёртки;
2. при передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

### 2. Unboxing

Происходит в следующих случаях:
1. при присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа;
2. в выражениях, где один или оба аргумента являются экземплярами классов-обёрток (например, арифметические операции `+`, `-`, `*`, `/`, `%`, операции сравнения `<`, `>`, `<=`, `>=`);

> Исключение: Операторы `==` и `!=` при сравнении двух объектов-обёрток сравнивают ссылки, а не значения (автораспаковка не происходит, если оба операнда - обёртки). Если один операнд примитив, а другой обёртка, то обёртка будет распакована.

3. при передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

 >Примечание: для `Byte`, `Short`, `Long` кэш также от -128 до 127. Для `Character` от 0 до 127. `Boolean` всегда использует `Boolean.TRUE` или `Boolean.FALSE`. `Float` и `Double` не кэшируют значения таким образом. Используйте `.equals()` для сравнения значений объектов-обёрток.
 
Автоупаковка и автораспаковка не работают для массивов целиком. Нельзя напрямую присвоить `int[]` к `Integer[]` или передать `Integer[]` в метод, ожидающий `int[]` (или `int...`) без преобразования элементов по одному.

Особенности:
* классы-обёртки неизменяемые (immutable);
* при каждой автоупаковке (за исключением значений из кэша) создается новый объект;
* в циклах или часто вызываемых методах это может привести к неразумному расходу памяти и увеличению нагрузки на сборщик мусора (Garbage Collector).

---
## Class Loaders

### Этапы получения работающего кода в JVM (согласно спецификации Java SE)

1. Загрузка (Loading):
	* поиск запрошенного класса среди уже загруженных;
	* получение байт-кода для загрузки;
	* проверка корректности байт-кода;
	* моздание экземпляра класса `java.lang.Class` (для работы с классом в runtime);
	* загрузка родительских классов и интерфейсов. (Если они не загружены, текущий класс тоже считается не загруженным).

2. Связывание (Linking / Линковка):
	* верификация (Verification): проверка корректности полученного байт-кода (структура, семантика);
	* подготовка (Preparation): выделение оперативной памяти под статические поля и инициализация их значениями по умолчанию (например, `0` для `int`, `null` для объектов). Явная инициализация происходит на этапе инициализации;
	* разрешение (Resolution): преобразование символьных ссылок (имена классов, полей, методов) в прямые ссылки на конкретные ячейки памяти.

3. Инициализация (Initialization):
	* выполнение статических блоков инициализации класса;
	* инициализация статических полей их явными значениями (если есть).

Отложенная (ленивая) загрузка классов:
- Java по умолчанию использует ленивую загрузку: классы, на которые ссылаются поля загружаемого класса, не загружаются до явного обращения к ним;
- разрешение символьных ссылок не обязательно сразу и по умолчанию не происходит;
- JVM может использовать и энергичную (eager) загрузку, где все символьные ссылки разрешаются сразу. Последнее требование выше (про ошибки разрешения) актуально для этого случая;
- разрешение символьных ссылок не привязано жестко к какому-либо этапу.

### Иерархия загрузчиков

1. Bootstrap ClassLoader (Базовый / Primordial):
	* корневой загрузчик;
	* реализация нативная (включена в JVM);
	* загружает стандартные классы JDK из `rt.jar` (и других основных JAR-файлов JRE, например, `resources.jar`, `charsets.jar`);
	* не является потомком `java.lang.ClassLoader`. `String.class.getClassLoader()` вернет `null` для классов, загруженных им.
 
2. Extension ClassLoader (Загрузчик расширений):
	* потомок Bootstrap ClassLoader;
	* реализация: `sun.misc.Launcher$ExtClassLoader` (в старых версиях), в Java 9+ часть модульной системы (загрузчик платформы);
	* загружает классы расширений из каталога `jre/lib/ext` (до Java 9) или определенных модулей. Путь может быть задан системным свойством `java.ext.dirs` (устарело).
 
3. System ClassLoader (Системный / Application ClassLoader):
	* потомок `Extension ClassLoade`r;
	* реализация: `sun.misc.Launcher$AppClassLoader` (в старых версиях), в Java 9+ часть модульной системы;
	* загружает классы приложения из путей, указанных в переменной среды `CLASSPATH`, или через опцию `-cp` / `-classpath` командной строки;
	* обычно является загрузчиком для классов, написанных разработчиком.

Каждый загрузчик хранит указатель на родительский для делегирования.

Абстрактный класс `java.lang.ClassLoader`:
- все загрузчики (кроме Bootstrap) являются потомками `java.lang.ClassLoader`;
- позволяет создавать пользовательские загрузчики, переопределяя его методы.

### Три принципа загрузки классов

1. Делегирование (Delegation):
	- запрос на загрузку класса передается родительскому загрузчику;
	- попытка загрузить класс самостоятельно выполняется, только если родитель (и его предки) не смогли найти и загрузить класс;
	- позволяет загружать классы тем загрузчиком, который максимально близок к базовому (Bootstrap);
	- достигается максимальная область видимости и предотвращается перезагрузка классов ядра Java.

2. Видимость (Visibility):
	- загрузчик "видит" только классы, загруженные им самим, и классы, загруженные его родителями (и предками);
	- загрузчик "не видит" классы, загруженные его потомками.

3. Уникальность (Uniqueness):
	- класс (определяемый полным именем + загрузчиком) может быть загружен в JVM только однажды;
	- механизм делегирования помогает обеспечить, что один и тот же класс не будет загружен разными загрузчиками из одной иерархии, если он уже доступен через родителя.

При написании своего загрузчика следует руководствоваться этими принципами.

Ход загрузки: 

![[Resources/ClassLoader/512.jpeg]]

Запрос идет "вверх" по иерархии (делегирование), а фактический поиск и загрузка (если класс еще не был загружен) идет "вниз" от того загрузчика, который первым сможет его найти в своих источниках (начиная с `Bootstrap`).

Исключения: 
- `ClassNotFoundException`: возникает при динамической загрузке класса (`Class.forName()`, `ClassLoader.loadClass()`), когда загрузчики не могут найти класс ни в кэше, ни по путям поиска.
- `NoClassDefFoundError`: возникает, когда класс был доступен во время компиляции, но JVM не может найти его определение во время выполнения (например, отсутствует JAR-файл в classpath, или класс не смог инициализироваться из-за ошибки в статическом блоке).

---
## Serializable и Externalizable

Интерфейс `Serializable` применяется для стандартной сериализации объектов. Это маркерный интерфейс, то есть он не содержит методов, а управление процессом сериализации полностью берёт на себя JVM. Такой подход упрощает использование, но не позволяет программисту контролировать, какие поля сохраняются и как. Также сериализация через `Serializable` может быть менее производительной и не требует наличия конструктора без параметров. Однако любые изменения в структуре класса могут повлиять на совместимость сериализации, и сохранить только часть объекта невозможно. Ключевое слово `transient` используется для исключения полей из сериализации.

Интерфейс `Externalizable`, в отличие от `Serializable`, требует реализации методов `writeExternal()` и `readExternal()`, что даёт программисту полный контроль над процессом сериализации и десериализации. JVM в этом случае не управляет процессом, вся логика реализуется вручную. Такой способ обеспечивает лучшую производительность и гибкость: можно сохранить только необходимые части объекта. Однако при использовании `Externalizable` необходимо иметь публичный конструктор без параметров, а ключевое слово `transient` не влияет на процесс сериализации.

---
## Generics

Проблемы до дженериков:
- без дженериков: код требовал ручных проверок и приведения типов;
- риск: `ClassCastException` во время выполнения, если в коллекцию попал объект не того типа.

С дженериками (`List<Account>`) тип коллекции задается при объявлении, добавяляя типобезопасность на этапе компиляции. Компилятор не позволит добавить в `List<Account>` объект другого типа и сам выполняет неявное приведение типов. 

Принцип подстановки Лисков: объект подтипа (наследника) можно использовать везде, где ожидается объект супертипа (родителя), без нарушения работы программы. Пример: `Number n = Integer.valueOf(42); (Integer — подтип Number)`.

Ковариантность — иерархия наследования сохраняется (String[] является подтипом Object[]).

>Массивы — ковариантны. Это рискованно, так как ошибка типа (ArrayStoreException) проявляется только во время выполнения.

Контравариантность — иерархия наследования обращается (`Comparator<Object>` является подтипом `Comparator<String>`).

Инвариантность — Иерархия не наследуется (`List<String>` не является подтипом `List<Object>`).

>Дженерики — инвариантны (по умолчанию). Это безопасно, так как ошибка типа обнаруживается на этапе компиляции.

Wildcards делают дженерики более гибкими, добавляя им ковариантность и контравариантность:
- `List<? extends T>` (Upper Bounded / Ковариантность):
 - означает "список T или любого его наследника";
 - можно только читать (get);
 - запись запрещена (кроме null), так как компилятор не знает точного типа.
- `List<? super T>` (Lower Bounded / Контравариантность):
	- означает "список T или любого его родителя";
	- можно только записывать (add) объекты типа T; 
	- чтение вернет только Object.

Принцип PECS (Producer Extends, Consumer Super):
- если коллекция поставляет данные (вы из нее только читаете), используйте extends;
- если коллекция потребляет данные (вы в нее только пишете), используйте super.

`<?>` (Unbounded Wildcard):
- эквивалентна `<? extends Object>`;
- безопасна, но сильно ограничена (можно только читать как Object).

Raw-типы (типы без указания дженерика): 
- наследие старых версий Java; 
- их следует избегать, так как они отключают всю проверку типов и могут привести к Heap Pollution (загрязнению кучи).

>Unchecked Warning: Предупреждение компилятора о том, что операция не является типобезопасной (обычно при работе с Raw-типами).

Type Erasure (Стирание типов):
- компилятор удаляет всю информацию о дженериках (`<T>`, `<String>`) во время компиляции, заменяя их на их границы (или на Object) и добавляя необходимые приведения типов;
- обеспечивает обратную совместимость с кодом, написанным до появления дженериков;
- информация о дженериках (`List<String>`) недоступна во время выполнения.

Код до стирания:

```java
class Node < T > {
  public T data;

  public Node(T data) {
    this.data = data;
  }

  public void setData(T data) {
    System.out.println("Node.setData");
    this.data = data;
  }
}

class MyNode extends Node < Integer > {
  public MyNode(Integer data) {
    super(data);
  }

  public void setData(Integer data) {
    System.out.println("MyNode.setData");
    super.setData(data);
  }
}

public class Example {
  public static void main(String[] args) {
    MyNode mn = new MyNode(5);
    Node n = mn;
    n.setData("Hello");
    Integer x = mn.data;
  }
}
```

Код после стирания:

```java
public class Node {
  public Object data;

  public Node(Object data) {
    this.data = data;
  }

  public void setData(Object data) {
    System.out.println("Node.setData");
    this.data = data;
  }
}

public class MyNode extends Node {

  public MyNode(Integer data) {
    super(data);
  }

  public void setData(Integer data) {
    System.out.println("MyNode.setData");
    super.setData(data);
  }
}

public class Example {
  public static void main(String[] args) {
    MyNode mn = new MyNode(5);
    Node n = (MyNode) mn;
    n.setData("Hello");
    Integer x = (String) mn.data;
  }
}
```

Можно заметить, что после стирания типов сигнатуры метода `setData` в `MyNode` и `Node` больше не совпадают, а значит субкласс не переопределяет метод и полиморфизм оказывается сломан. Чтобы исправить эту ситуацию, компилятор генерирует для `MyNode` bridge-метод следующего вида:

```java
public void setData(Object data) {
  setData((Integer) data);
}
```

Увидеть его можно, заглянуть в байткод с помощью команды `javap -c -v MyNode`:

```java
 public void setData(java.lang.Object);
 descriptor: (Ljava/lang/Object;)V
 flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
 Code:
 stack=2, locals=2, args_size=2
 0: aload_0
 1: aload_1
 2: checkcast #6 // class java/lang/Integer
 5: invokevirtual #7 // Method setData:(Ljava/lang/Integer;)V
 8: return
```

Reifiable Types — тип, информация о котором полностью доступна во время выполнения. К данному типу относятся следующие типы данных: примитивы (int), непараметризованные типы (`String`), raw-типы (`List`), неограниченные wildcards (`List<?>`). 

К Non-reifiable: параметризованные типы (`List<String>`), переменные типа (`T`), ограниченные wildcards (`List<? extends Number>`).

В результате, нельзя делать `new T()`, `instanceof` `List<String>`, `class MyEx<T> extends Exception {}`, так как во время выполнения тип `T` или `String` неизвестен.

Heap Pollution возникает, когда в параметризованную коллекцию попадает объект другого типа из-за смешивания с Raw-типами. Приводит к `ClassCastException` в неожиданном месте.

---
## Аннотации

Аннотации — это особые синтаксические метаданные, которые используются компилятором для различных целей.

Тип хранения определяет, насколько долго аннотация сохраняется в процессе обработки кода. Это указывается через элемент `RetentionPolicy` и бывает трёх видов:
- `SOURCE` — аннотация существует только в исходном коде и отбрасывается во время компиляции;

 >Используется для подсказок компилятору или инструментов анализа кода.

- `CLASS` — аннотация сохраняется в `.class` файле, но не загружается JVM во время выполнения; 

>Применяется для сторонних инструментов и библиотек, работающих на этапе загрузки классов.

- `RUNTIME` — аннотация сохраняется и доступна во время выполнения программы через рефлексию. 

>Подходит для аннотаций, которые напрямую влияют на поведение приложения.
 
Аннотации в Java могут быть применены к разным элементам кода. С помощью `ElementType` указывается, где именно аннотация допустима. Возможные варианты:
- `ANNOTATION_TYPE` — другая аннотация;
- `CONSTRUCTOR` — конструктор;
- `FIELD` — поле класса;
- `LOCAL_VARIABLE` — локальная переменная;
- `METHOD` — метод;
- `PACKAGE` — объявление пакета;
- `PARAMETER` — параметр метода (например: `public void greet(@Default String name)`);
- `TYPE` — класс, интерфейс или перечисление.

---
## String

String Pool в Java — это специальная часть памяти в куче, предназначенная для хранения строковых литералов. Этот механизм называется строковым пулом (или intern pool) и позволяет JVM экономить память за счёт повторного использования неизменяемых строк.

До Java 7 пул строк находился в области PermGen — специальной части памяти, где JVM хранила метаданные классов, статические поля и строковые литералы.

Начиная с Java 7 пул строк был перемещён в основную кучу (Heap), что позволило устранить ограничения PermGen и улучшить управление памятью. В Java 8 PermGen была полностью удалена.

Когда вы создаёте строку с помощью литерала (например, `String s = "Hello";`), JVM проверяет, есть ли уже такая строка в пуле:
- если строка уже есть, возвращается ссылка на существующий объект;
- если строки нет, создаётся новый объект, и он добавляется в пул.

Пример:

```java
String s1 = "Hello";
String s2 = "Hello";
```

Обе переменные будут ссылаться на одну и ту же строку в пуле.

Однако, если строка создаётся через `new` будет создан новый объект в куче, не связанный со строковым пулом:

```java
String s3 = new String("Hello");
```

Чтобы поместить его в пул, используется метод `intern()`:

```java
String s4 = new String("Hello").intern();
```

---
## Клонирование

Клонирование — это процесс создания копии объекта с сохранением его состояния.

### Виды клонирования

1. Поверхностное (Shallow Copy):
	- копируются только значения полей (включая ссылки);
	- объекты, на которые ссылаются поля, не клонируются — копируются только ссылки.

2. Глубокое (Deep Copy): копируются и сам объект, и все вложенные объекты, т.е. создается полностью независимая копия.

Для клонирования класс должен:
- реализовать интерфейс `Cloneable`;
- переопределить метод `clone()` из класса `Object`.

Пример: 

```java
public class Person implements Cloneable {
  int id;
  String name;

  public Object clone() throws CloneNotSupportedException {
    return super.clone();
  }
}
```

Метод `clone()` по умолчанию реализует поверхностное копирование. Для глубокого — нужно вручную клонировать вложенные объекты.

Особенности:
- без реализации `Cloneable` вызов `clone()` бросит `CloneNotSupportedException`;
- клонирование нарушает инкапсуляцию, т.к. `Object.clone()` — protected.

Также можно создать копирующий конструктор или использовать сериализацию/библиотеки (например, Apache Commons Lang `SerializationUtils.clone()`).

---
## Reflection API в Java

Reflection API (Рефлексия) — механизм, позволяющий в рантайме получать информацию о классах, конструкторах, методах, полях, аннотациях и т.д., а также изменять их.

Основные классы из пакета `java.lang.reflect`:
- `Class<T>` — основной класс для получения метаданных;
- `Field` — работа с полями;
- `Method` — работа с методами;
- `Constructor` — работа с конструкторами.

Пример:

```java
Class<?> clazz = Class.forName("com.example.Person");
Object obj = clazz.getDeclaredConstructor().newInstance();
Method method = clazz.getMethod("sayHello");
method.invoke(obj);
```

При помощи рефлексии можно делать следующее:
- узнать имя класса, пакета, суперкласса;
- получить список методов, полей, конструкторов;
- вызывать методы, даже приватные;
- изменять значения полей;
- создавать экземпляры объектов;
- проверять наличие аннотаций;
 
Преимущества:
- гибкость (можно писать универсальный код, например, для сериализации, логирования, DI-фреймворков);
- используется во многих фреймворках: Spring, Hibernate, JUnit.
 
Недостатки:
- медленнее обычного вызова;
- нарушает инкапсуляцию и безопасность;
- могут возникать ошибки в рантайме (например, `NoSuchMethodException`, `IllegalAccessException`).

---
## JIT-компилятор в HotSpot JVM

AOT (Ahead-of-Time) компиляция — исходный код сразу компилируется в машинный код для конкретной архитектуры процессора. Особенности:
- плюс: высокая производительность;
- минус: код, скомпилированный для одного процессора, может не работать на другом (низкая портативность).

Интерпретация — интерпретатор выполняет исходный код "на лету". Особенности:
- плюс: высокая портативность;
- минус: низкая производительность.

Java (гибридный подход):
1. исходный код (.java) компилируется в байт-код (.class);
2. JVM интерпретирует байт-код;
3. JIT (Just-in-Time) компилятор транслирует "горячий" (часто выполняемый) байт-код в оптимизированный машинный код прямо во время выполнения программы.

### HotSpot JIT-компилятор

JVM не компилирует весь код сразу. Она отслеживает "горячие точки" (hot spots) — методы и циклы, которые выполняются чаще всего, — и компилирует только их.

Преимуществом токого подхода является экономия ресурсов (не тратится время на компиляцию редко используемого кода). Чем дольше работает приложение, тем больше статистики (профиля) собирает JVM, что позволяет ей применять всё более продвинутые оптимизации. Единицей компиляции является метод или цикл, а результатом — nmethod (native method). 

### Многоуровневая компиляция (Tiered Compilation)

В HotSpot JVM есть два компилятора: C1 (client) и C2 (server).
- C1: быстрый, но с меньшим уровнем оптимизации;
- C2: медленный, но генерирует высокооптимизированный код.

С Java 8 по умолчанию включена многоуровневая компиляция, которая использует оба компилятора в несколько этапов:
- Уровень 0: интерпретация байт-кода;
- Уровень 1-3: компиляция с помощью C1 с разным уровнем профилирования. 

>Код быстро становится скомпилированным, но не максимально быстрым.

- Уровень 4: компиляция с помощью C2. 

>Когда код становится достаточно "горячим", C2 перекомпилирует его с максимальной оптимизацией.

Типичный путь: 0 (интерпретатор) -> 3 (C1 с профилированием) -> 4 (C2). Эта система позволяет быстро "разогреть" приложение с помощью C1 и затем довести его до пиковой производительности с помощью C2.

### Code Cache

Code Cache — cпециальная область памяти, где JVM хранит сгенерированный машинный код.

Имеет ограниченный размер. Если кэш переполняется, JIT-компилятор отключается, и новый "горячий" код перестает компилироваться, оставаясь на медленном уровне интерпретации.

Размер можно увеличить флагами `-XX:InitialCodeCacheSize` и `-XX:ReservedCodeCacheSize`.

Code Cache разделен на 3 части (с Java 9):
1. JVM internal: для внутреннего кода JVM;
2. Profiled code: для кода, скомпилированного C1 (уровни 1-3);
3. Non-profiled code: для высокооптимизированного кода от C2 (уровень 4).

### Мониторинг работы компилятора

- 1. Логирование (`-XX:+PrintCompilation`):
	- выводит в консоль информацию о каждой компиляции;
	- формат: timestamp compilation_id attributes tiered_level method_name size;
	- важный атрибут: % означает OSR (On-Stack Replacement) — компиляцию "на лету" для долгого цикла, который уже выполняется. 

- 2. Утилита jstat:
	- не требует перезапуска приложения;
	- `jstat -compiler [pid]`: Сводная информация о количестве скомпилированных методов;
	- `jstat -printcompilation [pid] 1000`: Показывает последний скомпилированный метод каждую секунду. Позволяет наблюдать за процессом в реальном времени.

---
## Типы ссылок

### Стандартная ссылка

Объект НЕ БУДЕТ удален сборщиком мусора, пока на него существует хотя бы одна сильная ссылка.

Пример: `String s = "Hello"` (s — это сильная ссылка).

### SoftReference

Объект, на который есть только мягкие ссылки, будет удален только в том случае, если JVM критически не хватает памяти (перед тем, как выбросить `OutOfMemoryError`). Идеально подходит для реализации кэшей (например, кэш изображений). Пока память есть, кэш работает быстро. Если память заканчивается, JVM сама очистит кэш, чтобы избежать падения приложения.

### WeakReference

Объект, на который есть только слабые ссылки, будет удален при следующем же запуске сборщика мусора, независимо от того, есть ли свободная память. Идеально для хранения метаданных, которые должны существовать ровно столько, сколько существует основной объект. Классический пример — `WeakHashMap`, где ключи хранятся как слабые ссылки. Как только на ключ не остается сильных ссылок извне, вся запись (ключ-значение) удаляется из Map.

### PhantomReference

Объект удаляется сборщиком в любой момент, как и в случае с `WeakReference`. Получить сам объект через фантомную ссылку невозможно (метод `get()` всегда возвращает `null`). Используется только вместе с `ReferenceQueue` для выполнения каких-либо действий после того, как объект был финализирован и готовится к удалению из памяти (например, для очистки нативных ресурсов). Это более надежная альтернатива методу `finalize()`.

### ReferenceQueue (Очередь ссылок)

Очередь, в которую помещаются "умершие" ссылки (Soft, Weak, Phantom) после того, как сборщик мусора решил удалить их объекты-референты. Позволяет отслеживать, какие объекты были удалены, и выполнять связанные с этим задачи по очистке. Особенно важна для `PhantomReference`.

---
## Утечка памяти

Утечка памяти в Java — это ситуация, когда в куче накапливаются объекты, которые больше не используются приложением, но сборщик мусора не может их удалить, потому что на них все еще существуют активные ссылки. В результате память не освобождается, что со временем приводит к замедлению работы, сбоям и, в конечном итоге, к ошибке java.lang.OutOfMemoryError.

### Основные причины и типы утечек памяти

1. Объекты, на которые ссылаются static переменные, "живут" столько же, сколько само приложение. Если в статическую коллекцию (например, List) постоянно добавлять объекты, они никогда не будут удалены.

> Частный случай — Singleton: Шаблон Singleton по своей природе использует статическое поле для хранения единственного экземпляра. Если этот экземпляр накапливает внутреннее состояние (например, имеет растущий список), это приведет к утечке. Для решения проблемы можно использовать ленивую инициализацию.

2. Ресурсы вроде потоков ввода-вывода (`InputStream`), сетевых соединений (`Socket`) или соединений с БД (`Connection`) занимают память, если их не закрывать, память не освободится. Можно использовать конструкцию try-with-resources (начиная с Java 7) или всегда закрывать ресурсы в блоке `finally`.

3. Коллекции типа `HashSet` и `HashMap` используют `equals()` и `hashcode()` методы для определения уникальности элементов. Если они не переопределены, коллекция будет накапливать дубликаты, занимая лишнюю память.

4. Использование Map в качестве простого кэша без механизма очистки. Если в кэш постоянно добавлять новые элементы, он будет расти бесконечно, пока не исчерпает всю память. Нужно использовать специальные реализации кэша (`WeakHashMap`, `Guava Cache`, `Ehcache`) или реализовать собственную политику вытеснения (eviction policy), например, по размеру или времени жизни.

5. Классическая утечка в observer-шаблоне. Объект-издатель хранит сильные ссылки на своих слушателей. Если слушатель не будет явно отписан (unregistered) после того, как он станет не нужен, он и все объекты, на которые он ссылается, останутся в памяти.

6. Нестатический (в том числе анонимный) внутренний класс неявно хранит ссылку на экземпляр своего внешнего класса. Если объект внутреннего класса "живет" дольше объекта внешнего, он будет удерживать внешний класс в памяти. Если внутреннему классу не нужен доступ к полям внешнего, нужно сделать его static.

7. В серверах приложений потоки из пула переиспользуются. Если не очистить `ThreadLocal` переменную после использования, ее значение останется "привязанным" к потоку и будет жить вечно, вызывая утечку. Нужно всегда вызывать метод `threadLocal.remove()` в блоке `finally`.

8. Метод `intern()` помещает строку в глобальный строковый пул, откуда она никогда не удаляется. Использование этого метода на большом количестве уникальных строк приведет к переполнению пула (в старых версиях Java — PermGen, в новых — кучи).

9. Утечка может находиться не в вашем коде, а внутри используемой библиотеки, которая, например, имеет собственный статический кэш или некорректно управляет ресурсами.

### Стратегии борьбы с утечками памяти

1. Использовать Java-профайлеры (например, VisualVM, JProfiler) для анализа использования памяти и поиска "подозрительных" объектов.

2. Включить детальное логирование сборщика мусора (`-verbose:gc`) для отслеживания его работы.

3. Применять `WeakReference` и `SoftReference` там, где это уместно (например, для кэшей или метаданных), чтобы позволить GC удалять объекты при необходимости.

4. Сравнивать производительность и потребление памяти разными реализациями одного и того же функционала.

5. Регулярная проверка кода помогает выявлять потенциальные проблемы на ранних этапах.

---
## Объект

Все классы в Java неявно наследуют класс `java.lang.Object`. Этот класс определяет базовые методы, которые есть у любого объекта.

Методы класса `Object`:

|Метод|Описание|
|---|---|
|`equals()`|Сравнение объектов|
|`hashCode()`|Хэш-код для объекта|
|`toString()`|Строковое представление объекта|
|`clone()`|Клонирование объекта|
|`finalize()`|Очистка перед сборкой мусора (deprecated)|
|`getClass()`|Получение класса объекта|
|`notify()`|Возобновить один ожидающий поток|
|`notifyAll()`|Возобновить все ожидающие потоки|
|`wait()`|Ожидание уведомления|
|`wait(timeout)`|Ожидание с тайм-аутом|
|`wait(timeout, nanos)`|Ожидание с тайм-аутом и наносекундами|

Порядок инициализации:

| Этап | Пояснение |
| ------------------------- | ------------------------------- |
| Статические поля Parent | Инициализируются при загрузке |
| Статический блок Parent | Выполняется при загрузке |
| Статические поля Child | Инициализируются после Parent |
| Статический блок Child | Выполняется после Parent |
| Нестатические поля Parent | Инициализируются при создании |
| Нестатический блок Parent | Выполняется перед конструктором |
| Конструктор Parent | Вызывается при создании |
| Нестатические поля Child | Инициализируются после Parent |
| Нестатический блок Child | Выполняется перед конструктором |
| Конструктор Child | Выполняется последним |

---
## Прокси

Прокси-классы — это мощный инструмент для динамического изменения поведения объектов. Они позволяют "перехватывать" вызовы методов и добавлять свою логику (например, для логирования, транзакций, кэширования).

### Способы создания прокси

1. Работает через рефлексию и интерфейс `InvocationHandler`. Создает анонимный класс во время выполнения. Может создавать прокси только для классов, реализующих интерфейсы. Прокси нельзя привести к конкретному классу (User), а только к его интерфейсу (IUser).

Пример:

```java
// Default
User user = new User("Вася");

// Логика перехвата вызовов
InvocationHandler handler = (proxy, method, args) -> {
  if (method.getName().equals("getName")) {
    return ((String) method.invoke(user, args)).toUpperCase();
  }
  return method.invoke(user, args);
};

// Создание прокси
IUser userProxy = (IUser) Proxy.newProxyInstance(
  user.getClass().getClassLoader(),
  user.getClass().getInterfaces(),
  handler
);

assertEquals("ВАСЯ", userProxy.getName());
```

2. Работает через модификацию байт-кода (использует библиотеку ASM). Создает подкласс (наследника) для проксируемого объекта. Может создавать прокси для конкретных классов, не требуя интерфейсов. Не может проксировать final методы и классы, так как основан на наследовании.

Пример:

```java
// CGLIB
User user = new User("Вася");

MethodInterceptor handler = (obj, method, args, proxy) -> {
  if (method.getName().equals("getName")) {
    return ((String) proxy.invoke(user, args)).toUpperCase();
  }
  return proxy.invoke(user, args);
};

// Создание прокси с помощью "улучшателя" (Enhancer)
User userProxy = (User) Enhancer.create(User.class, handler);

assertEquals("ВАСЯ", userProxy.getName());
```

3. Еще одна библиотека для работы с байт-кодом. Создание прокси требует нескольких шагов: создание фабрики, её настройка, создание класса и экземпляра.

- Пример:

```java
//Javassist
User user = new User("Вася");

MethodHandler handler = (self, overridden, forwarder, args) -> {
  if (overridden.getName().equals("getName")) {
    return ((String) overridden.invoke(user, args)).toUpperCase();
  }
  return overridden.invoke(user, args);
};

ProxyFactory factory = new ProxyFactory();
factory.setSuperclass(User.class);

// Создание и настройка экземпляра
Object instance = factory.createClass().newInstance();
((ProxyObject) instance).setHandler(handler);

User userProxy = (User) instance;
assertEquals("ВАСЯ", userProxy.getName());
```


4. Современная библиотека для работы с байт-кодом, известная своим гибким и читаемым API. Логика описывается декларативной цепочкой вызовов, часто с делегированием логики в отдельный класс-перехватчик.

Пример:

```java
// ByteBuddy
User user = new User("Вася");

// Создание прокси через "строитель"
User userProxy = new ByteBuddy()
  .subclass(User.class)
  .method(named("getName"))
  .intercept(MethodDelegation.to(new MyInterceptor(user)))
  .make()
  .load(User.class.getClassLoader())
  .getLoaded()
  .newInstance();

assertEquals("ВАСЯ", userProxy.getName());

// Класс-перехватчик для делегирования
public class MyInterceptor {
  private User user;

  public MyInterceptor(User user) {
    this.user = user;
  }

  public String getName() {
    return user.getName().toUpperCase();
  }
}
```

Сравнение JDK Dynamic Proxy и CGLIB

| Характеристика | JDK Dynamic Proxy | CGLIB |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| Механизм | Рефлексия, создание анонимного класса, реализующего интерфейс. | Манипуляция байт-кодом (ASM), создание подкласса (наследника). |
| Основное требование | Объект должен реализовывать интерфейс. | Интерфейс не обязателен. Может проксировать классы напрямую. |
| Ограничение | Не может проксировать классы без интерфейсов. | Не может проксировать final классы и методы. |
| Производительность | Исторически CGLIB был быстрее. Начиная с JDK 6-8, производительность JDK Proxy была значительно улучшена и часто превосходит CGLIB. | Производительность выще если больше запросов. |
| Использование в Spring | По умолчанию: если у бина есть интерфейс, используется JDK Proxy. | Если у бина нет интерфейса, используется CGLIB. Можно принудительно включить CGLIB через <aop:aspectj-autoproxy proxy-target-class="true"/>. |

---
## Java 8

### 1. Методы по умолчанию в интерфейсах (Default Methods)

Появилась возможность добавлять в интерфейсы методы с реализацией, используя ключевое слово default. Теперь можно расширять интерфейсы, не ломая обратную совместимость. Классы, реализующие такой интерфейс, не обязаны переопределять default-метод.

### 2. Лямбда-выражения (Lambda Expressions)

Короткий синтаксис для написания анонимных функций. Позволяет заменять громоздкие анонимные классы, делая код более читаемым и компактным.

Лямбда-выражения представляют собой альтернативу анонимным классам, но между ними есть ключевые различия.

Общие черты:
- можно использовать только `final` или effectively final локальные переменные;
- доступны поля класса (в том числе статические);
- не могут выбрасывать исключения, не объявленные в `throws` функционального интерфейса.

Различия:
- в анонимных классах `this` ссылается на сам класс, а в лямбда-выражениях — на внешний класс;
- анонимные классы компилируются во внутренние классы, тогда как лямбда-выражения преобразуются в `private static`-методы с использованием `invokedynamic`, что делает их более эффективными (не требуется загрузка дополнительного класса).

При работе с лямбда-выражениями и анонимными классами в Java Stream API часто требуется, чтобы внешние переменные были неизменяемыми (`final` или effectively final). Это связано со следующими причинами:
1. иммутабельность и ссылочная прозрачность — лямбда-выражения требуют final/effectively final переменных, чтобы сохранить принцип функционального программирования, при котором результат зависит только от входных данных, а не от изменяемого состояния;
2. безопасность в многопоточных сценариях — ограничение на final/effectively final переменные предотвращает race condition при параллельном выполнении Stream API, гарантируя потокобезопасность;
3. механизм замыканий — лямбда-выражения захватывают переменные из внешнего контекста, и требование неизменяемости обеспечивает стабильность их поведения, так как значение переменной остаётся фиксированным после создания лямбды.

Таким образом, ограничение на `final` / effectively final переменные обеспечивает корректную и безопасную работу лямбда-выражений в Stream API.

### 3. Функциональные интерфейсы

Интерфейс, который содержит ровно один абстрактный метод. Лямбда-выражение всегда имеет тип функционального интерфейса.

>@FunctionalInterface — необязательная, но помогает компилятору проверить, что в интерфейсе действительно только один абстрактный метод.

### 4. Ссылки на методы и конструкторы (Method References)

Еще более короткий синтаксис для лямбд, которые просто вызывают уже существующий метод.

>Используется оператор ::

Типы:
- ссылка на статический метод: Integer::valueOf;
- ссылка на метод экземпляра: someObject::someMethod;
- ссылка на конструктор: Person::new.

### 5. Области видимости лямбд

Лямбды могут использовать локальные переменные из внешней области, если они final или фактически неизменяемые (effectively final). Могут свободно читать и изменять поля класса и статические переменные. Только нельзя получить доступ к default-методам интерфейса напрямую из лямбды.

### 6. Встроенные функциональные интерфейсы

В Java 8 появилось много готовых интерфейсов:
- `Predicate<T>` — принимает T, возвращает boolean (для фильтрации);
- `Function<T, R>` — принимает T, возвращает R (для преобразования);
- `Supplier<T>` — мничего не принимает, возвращает T (для создания объектов);
- `Consumer<T>` — принимает T, ничего не возвращает (void, для выполнения действий);
- `Comparator<T>` — принимает (T, T), возвращает int (для сравнения).

### 7. Optional

Класс-контейнер, который может содержать или не содержать значение (null). Элегантный способ избежать `NullPointerException`.

Ключевые методы: `isPresent()`, `get()`, `orElse()`, `ifPresent()`.

### 8. Stream API

API для работы с последовательностями элементов в функциональном стиле. Предназначена для коллекций, массив и т.д.

#### Типы

1. Промежуточные операции (Intermediate) возвращают новый поток. Примеры: `filter()`, `map()`, `sorted()`. Данные операции ленивые. 

2. Конечные операции (Terminal) запускают обработку и возвращают результат. Примеры: `forEach()`, `collect()`, `count()`, `reduce()`, `anyMatch()`.

Вызов `parallelStream()` вместо `stream()` позволяет автоматически распараллелить выполнение операций на многоядерных процессорах, что может значительно ускорить обработку больших коллекций.

### 9. Новые методы в Map

Ассоциативные массивы получили новые удобные методы, такие как: `putIfAbsent()`, `forEach()`, `computeIfPresent()`, `getOrDefault()`, `merge()`.

### 10. Новый API для работы с датой и временем (java.time)

Неизменяемость (immutability) и потокобезопасность.

Основные классы:
- `LocalDate` — дата без времени и часового пояса (e.g., "2024-01-15");
- `LocalTime` — время без даты (e.g., "15:30:00");
- `LocalDateTime` — дата и время вместе;
- `ZoneId` — часовой пояс;
- `Instant` — момент времени на шкале UTC (машинное время);
- `DateTimeFormatter` — для форматирования и парсинга дат.

### 11. Повторяемые аннотации (Repeatable Annotations)

Возможность применять одну и ту же аннотацию к одному элементу кода несколько раз. Для требуется создать аннотацию-контейнер и пометить основную аннотацию с помощью `@Repeatable`. Для получения всех аннотаций используется новый метод рефлексии `getAnnotationsByType()`.

### 12. CompletableFuture

`CompletableFuture` — это класс в Java 8, предназначенный для асинхронного программирования. Он позволяет выполнять задачи в отдельных потоках, не блокируя основной поток, и предоставляет мощные средства для обработки результатов этих задач.

`CompletableFuture` решает основные проблемы своего предшественника, Future, а именно:
- невозможность завершить вручную;
- отсутствие неблокирующих колбэков;
- сложность в построении цепочек асинхронных задач;
- отсутствие удобных средств для объединения нескольких задач;
- отсутствие встроенной обработки исключений.

#### Создание 

1. Асинхронные вычисления с ручным управлением. Пример:

```java
CompletableFuture<String> future = new CompletableFuture<>();

// Где-то в другом месте программы
future.complete("Результат готов!");

// Блокирующий вызов для получения результата
String result = future.get(); // "Результат готов!"
```

2. Запуск void-задачи в фоновом потоке. Пример:

```java
CompletableFuture < Void > future = CompletableFuture.runAsync(() -> {
  // Имитация длительной работы
  System.out.println("Задача выполняется в другом потоке...");
});

future.get(); // Ждем завершения
```

3. Запуск задачи с возвратом результата асинхронно Пример:

```java
CompletableFuture < String > future = CompletableFuture.supplyAsync(() -> {
  // Имитация длительной работы
  return "Результат асинхронной задачи";
});

String result = future.get(); // "Результат асинхронной задачи"
```

> По умолчанию задачи выполняются в общем пуле потоков ForkJoinPool.commonPool(). Можно передать собственный Executor в качестве второго аргумента в runAsync или supplyAsync.

#### Обработка результатов (Колбэки)

Ключевое преимущество `CompletableFuture` — возможность прикрепить неблокирующие колбэки для обработки результата.

1. Преобразование результата. Принимает `Function<T, R>`, преобразует результат типа T в результат типа R. Пример:

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "World")
 .thenApply(name -> "Hello, " + name)
 .thenApply(greeting -> greeting + "!");

System.out.println(future.get()); // "Hello, World!"
```

2. Потребление результата без возврата. Принимает `Consumer<T>`, выполняет действие с результатом, но ничего не возвращает (void). Пример:

```java
CompletableFuture.supplyAsync(() -> "Product Details")
 .thenAccept(details -> System.out.println("Получены детали: " + details));
```

3. Завершающее действие без доступа к результату. Принимает `Runnable`, выполняет действие после завершения, не имея доступа к результату. Пример:

```java
CompletableFuture.supplyAsync(() -> "Some result")
 .thenRun(() -> System.out.println("Задача завершена."));
```

> Все эти методы имеют Async-версии (thenApplyAsync, thenAcceptAsync), которые гарантируют выполнение колбэка в другом потоке, а не в том, где завершилась основная задача.

#### Объединение CompletableFuture

1. Последовательное объединение. Используется, когда вторая асинхронная задача зависит от результата первой. Позволяет избежать вложенных `CompletableFuture<CompletableFuture<T>>`. Пример: 

```java
CompletableFuture<Double> result = getUserDetails(userId)
 .thenCompose(user -> getCreditRating(user)); // getCreditRating возвращает CompletableFuture
```

2. Параллельное объединение независимых `Future`. Используется, когда нужно запустить две независимые задачи и обработать их результаты вместе. Пример: 

```java
CompletableFuture<Double> weightFuture = CompletableFuture.supplyAsync(() -> 65.0);
CompletableFuture<Double> heightFuture = CompletableFuture.supplyAsync(() -> 177.8);

CompletableFuture<Double> bmiFuture = weightFuture.thenCombine(heightFuture, (weight, height) -> {
 // Логика расчета ИМТ
 return weight / ((height/100) * (height/100));
});

System.out.println("ИМТ: " + bmiFuture.get());
```

3. Ожидание всех `Future` / Ожидание любого Future

Типы:
	- `CompletableFuture.allOf()` — завершается, когда все переданные Future завершатся. Возвращает `CompletableFuture<Void>`.
	- `CompletableFuture.anyOf()` — завершается, когда любой из переданных Future завершится. Возвращает `CompletableFuture<Object>` с результатом первого завершившегося.

Пример `allOf`:

```java
CompletableFuture<String> future1 = ...;
CompletableFuture<String> future2 = ...;

CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);

allOf.thenRun(() -> {
 System.out.println("Обе задачи завершены.");
 // future1.join() и future2.join() теперь не заблокируют поток
});
```

#### Обработка исключений

1. Fallback-значение при возникновении исключения. Пример:

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
 if (true) throw new RuntimeException("Ошибка!");
 return "Успех";
}).exceptionally(ex -> {
 System.out.println("Произошла ошибка: " + ex.getMessage());
 return "Значение по умолчанию"; // Возвращаем запасное значение
});

System.out.println(future.get()); // "Значение по умолчанию"
```

2. Универсальная обработка результата, вызывается всегда, независимо от того, было исключение или нет. Пример:

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
 if (true) throw new RuntimeException("Ошибка!");
 return "Успех";
}).handle((result, ex) -> {
 if (ex != null) {
 System.out.println("Произошла ошибка: " + ex.getMessage());
 return "Значение по умолчанию";
 }
 return result.toUpperCase();
});

System.out.println(future.get()); // "Значение по умолчанию"
```
